---
author: haya
title: 2.引用计数法
date: 2020-03-06
article: true
timeline: true
category: java
tag:
- java
- jvm
- gc

---

## 1. 引用计数算法
>引用计数法中引入了一个概念，那就是“计数器”。计数器表示的是对象的人气指数，
也就是有多少程序引用了这个对象（被引用数）。计数器是无符号的整数，用于计数器的位数根据算法和实现而有所不同。

![collectors](/assets/java/jvm/gc/gc-ref.png)


被引用的对象不仅自己计数器要加1，其自己包含的引用的对象的计数器也要加1。
## 2.延迟引用计数法
引用计数法的缺点就是计数器值的增减处理繁重。
这里就引入了延迟引用计数法，延迟就是先不计数，等时机到了再计数。
引入一个 ZCT（Zero Count Table）表，来引用那些引用为0的对象。
被ZCT引用的对象可能不是垃圾。
当ZCT满时就遍历ZCT引用的对象，开始计算每一个对象被引用的值，计算完后回收那些引用依然为0的对象，剩下的就是有用的对象，再把它们的引用值清零。
## 3.Sticky引用计数法
该方法主要是觉得计数器的值用int类型有点浪费，推荐使用位数少的的数据类型来存储。书上是这样说的：

>计数器需要 1 个字（32 位机器就是 32 位）的空间。但是这样会大量消耗内存空间。
对此我们有个方法，那就是用来减少计数器位宽的“Sticky 引用计数法”。举个例子，我们假设用于计数器的位数为 5 位，那么这种计数器最多只能数到 2 的 5 次方减 1，也就是 31个引用数。如果此对象被大于 31 个对象引用，那么计数器就会溢出。这跟车辆速度计的指针爆表是一个状况。
针对计数器溢出（也就是爆表的对象），需要暂停对计数器的管理。对付这种对象，我们主要有两种方法。

两种方法是：
1. 什么都不做
   在快要溢出时，不再增加引用值，避免溢出。因为这样的概率太小，绝大多数对象的引用值不会超过1。
2. 采用标记-清除法辅助。。。